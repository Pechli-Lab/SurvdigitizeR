---
title: "Step-by-step-digitization"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Step-by-step-digitization}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = TRUE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,eval=FALSE, include=FALSE)
```

# Example of digitizer workflow

```{r eval=FALSE, include=FALSE}
# if not previously installed 
# library(devtools)
# install()
library(SurvdigtizeR)
```

```{r required-packages}
# Required packages and 

library(dplyr)
library(tidyr)
library(ggplot2)
library(stringr)

## We use this function for plotting arrays
fun_ggplot <- function(array, sen = 0.9){
  array%>% as.data.frame() %>%
    mutate(row = 1:n()) %>%
    gather(-row, key= "column", value = "val") %>%
    mutate(column = as.numeric(str_remove_all(column,"V"))) %>%
    filter( val < sen) %>% 
    ggplot(aes(x = column, y = row, fill = val )) +
    geom_tile() 
}
```




```{r function inputs}
curve_loc = here::here("vignettes","Test2OS.jpeg")
sen = 0.1
Wsen_i = 30
OCR_words_i = F
num_curves1 = 2
x_start_i = 0
x_end_i = 300
x_incr = 100
y_start_i = 0
y_end_i = 1
y_incr = .22
Y_values_vertical = F
```

### Reading in KM curves

```{r reading}

step1 <-fun_readsurv(FilePath = curve_loc)
fun_ggplot(step1[,,3])

```

```{r}
step2 <- fun_idplot(fig.hsl = step1,i.sen = sen)

fun_ggplot(step1[,,3]) +
  geom_vline(aes(xintercept = c(min(step2$axis$xaxis))), color = "green") +
  geom_vline(aes(xintercept = c(max(step2$axis$xaxis))), color = "green") +
  geom_hline(aes(yintercept = c(max(step2$axis$yaxis))), color = "green") +
  geom_hline(aes(yintercept = c(min(step2$axis$yaxis))), color = "green") +
  theme_bw()

```

### Removing 'non KM portions of the plot'

```{r clean plot}

step3 <-fun_cleanplot(fig.hsl = step2$fig.hsl,i.sen = sen, Wsen = Wsen_i,OCR_words = OCR_words_i )

step3 %>%
 ggplot(aes(x =x ,y =y)) +
 geom_point() +
 theme_bw()

```
### Detecting curves

```{r detecting-curves}

step4 <-fun_colordetect(fig.df = step3, num_curves = num_curves1, black_marks = F)

step4 %>%
 ggplot(aes(x =x ,y =y, color = as.factor(group))) +
 geom_point(size = 0.01) +
 theme_bw()

```

### Potential overlap

```{r potential overlap}
step5 <- overlap_detect(fig.grp =step4)

step5 %>%
 ggplot(aes(x =x ,y =y, color = as.factor(group))) +
 geom_point(size = 0.01) +
 theme_bw()

```

### Event detect

```{r}
step6 <-eventdetect(res.df = step5)
#
step6[[1]] %>%
  ggplot(aes(x =x ,y =y , color = curve)) +
  geom_point()
# 
# 
step6[[2]] %>%
  ggplot(aes(x =x ,y =y , color = curve)) +
  geom_point()
# 
```

### Remove points that are not concave

```{r}
step7 <-get_tofinal(res_list = step6)
```

### Mapping pixels to actual scales

```{r}
fig.BW <- step1[,,3]
step8 <- fun_range(X_start =x_start_i,
                    X_end = x_end_i,
                     X_increment = x_incr,
                     Y_end = y_end_i,
                     Y_start = y_start_i,
                     Y_increment = y_incr,
                     step1_bw =fig.BW,step2_axis = step2$axis,
                     Y_values_vertical = T)

```

```{r}
# Merging x and y-axis values with curve from gen_tofinal 
step9 <- fun_summary(final_list = step6,Step7_out =step8)

step9 %>%
 ggplot(aes(x = time, y = St, color = curve, group = curve)) +
 geom_step() +
 theme_bw()

```
